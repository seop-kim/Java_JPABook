CHAPTER 07
===
[ 고급 매핑 ]
---


주요 과정
---

| 주제                  | 내용                                                      |
|---------------------|---------------------------------------------------------|
| 상속 관계 매핑            | 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지 다룬다.                       |
| @MappedSuperclass   | 등록일, 수정일과 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속 받고자 할 때 사용한다. |
| 복합 키와 식별 관계 매핑      | 데이터베이스의 식별자가 있을 때 매핑하는 방법, 데이터베이스의 식별관계와 비식별 관계를 다룬다.   |
| 조인테이블               | 연관관계를 관리하는 연결테이블을 매핑하는 방법을 다룬다.                         |
| 엔티티 하나에 여러 테이블 매핑하기 | 하나의 엔티티에 다수의 테이블을 매핑하는 방법을 다룬다.                         |

<br><br>


> 상속 관계 매핑
- 관계형 데이터베이스에는 객체지향의 상속과 같은 개념은 없고 ```슈퍼타입 서브타입 관계``` 라는 것이 객체지향의 상속의 개념과 가장 유사하다.  
    ORM에서 이야기하는 상속 관계 매핑은 이 두개의 관계를 매핑하는 것이다.

- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현하는 방법은 3가지가 있다.

    |종류|설명|
    |---|---|
    | 각각의 테이블로 변환 ```(조인전략)``` | 각각을 모두 테이블로 만들고 조회할 때 조인을 사용하는 방법 (JPA에서는 조인 전략이라함)|
    | 통합 테이블로 변환 ```(단일 테이블 전략)```   | 테이블을 하나만 사용하여 모든 컬럼을 합쳐 사용한다 (단일 테이블 전략)|
    | 서브타입 테이블로 변환 ```(구현 클래스별 테이블 전략)``` | 서브 타입마다 하나의 테이블을 만든다. JPA에서는 구현 클래스마다 테이블 전략이라 한다.|


### 조인 전략
- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본키를 받아 본인의 키본키 + 외래키로 사용하는 전략이다.  
조회 시 조인을 자주 사용하게 되며 이 전략을 사용할 때의 주의점은 객체는 타입으로 가능하지만 테이블에는 타입이라는 개념이 없어 타입을 구분하는 컬럼을 추가해야 한다.

<br>

#### 부모객체 Item
```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}
```
<br>

#### 자식객체 Movie, Book, Album
```java
@Entity
@DiscriminatorValue("M")
public class Movie extends Item{
    private String director;
    private String actor;
}

@Entity
@DiscriminatorValue("B")
public class Book extends Item{
    private String author;
    private String isbn;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item{
    private String artist;
}
```

|종류|설명|
|---|---|
|@Inheritance(strategy = InheritanceType.JOINED)|상속매핑의 부모 클래스에 사용을 해야하며 매핑 전략을 지정해야 하는데 이 예제에서는 JOIN을 선택하여 JOINED 옵션을 주었다.
|@DiscriminatorColumn(name = "DTYPE")|부모 클래스에 구분 컬럼을 지정하는 어노테이션이다. 이 컬럼을 통해 자식테이블을 구분할 수 있다. ```name 옵션의 기본 값이 DTYPE이다.```|
|@DiscriminatorValue("M")|엔티티 저장 시 구분 컬럼에 입력할 값을 매개변수로 넣는다.|

<br>

#### ID 재정의
```java
@Entity
@DiscriminatorValue("B")
@PrimaryKeyJoinColumn(name = "BOOK_ID") // ID 재정의
public class Book extends Item{
    private String author;
    private String isbn;
}
```
- ID 재정의 : 상속관계의 매핑에서 기본적으로 부모객체의 ID 컬럼명을 그대로 사용한다. 만약 자식 객체의 기본 키 컬럼명을 변경하고자 한다면 ```@PrimaryKeyJoinColumn(name = "BOOK_ID")```를 사용하면 된다.

<br>

#### 조인 전략 정리  
- 장점
  - 테이블이 정규화된다.
  - 외래 키 참조 무결성 제약조건을 활용할 수 있다.
  - 저장공간을 효율적으로 사용한다.  


- 단점
  - 조회할 때 조인이 많이 사용되어 성능 저하가 발생할 수 있다.
  - 조회쿼리가 복잡하다.
  - 데이터 저장시 DML(Insert)가 2회 실행된다.


- 특징
  - JPA 표준 명세는 구분 컬럼을 사용하도록 하지만 하이버네이트를 호함한 몇몇 구현체는 구분 컬럼 없이도 동작을 한다.


- 관련 어노테이션
  - @PrimaryKeyJoinColumn
  - @DiscriminatorColumn
  - @DiscriminatorValue


